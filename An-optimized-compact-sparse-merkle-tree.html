<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>JJy | An optimized compacted sparse merkle tree</title>
  <link rel="stylesheet" href=" /css/main.css">
  <link href="/atom.xml" type="application/atom+xml" rel="alternate" title="ATOM Feed" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.6.0/css/all.min.css" integrity="sha512-Kc323vGBEqzTmouAECnVceyQqyqdsSiqLQISBL29aUW4U/M7pSPA/gEUZQqv1cwx4OnYxTxve5UMg5GT6L4JJg==" crossorigin="anonymous" referrerpolicy="no-referrer" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-light.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
  
  <!-- and it's easy to individually load additional languages -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/c.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/rust.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/javascript.min.js"></script>
  
  <script>hljs.highlightAll();</script>
</head>


<body>
  <header>
  <nav>
    <ul>
        <li><a href=" /">All</a></li>
        <li><a href=" /about">@JJy</a></li>
        <li><a href=" /atom.xml">RSS</a></li>
    </ul>
</nav>

</header>

  <main class="container">
    <article>
  <header>
    <h2>An optimized compacted sparse merkle tree</h2>
    <time datetime=" 2020-02-26" class="post-meta">2020-02-26</time>
    <p>
      
      <a class="post-link" href=" tags/merkletree">Merkletree</a>
      
      <a class="post-link" href=" tags/cryptography">Cryptography</a>
      
      <a class="post-link" href=" tags/english">English</a>
      
    </p>
  </header>
  <p>Sparse merkle tree is an advanced data structure used in the blockchain world. It can compress a large key-value map into short bytes represented merkle root and generates existence or non-existence proof for keys in the tree.</p>

<p>In this article, I describe a construction method and several optimizations, which together make the construction of the sparse merkle tree with the following attributes:</p>

<ul>
  <li>No pre-calculated hash set</li>
  <li>Efficient existence / non-existence proof</li>
  <li>Efficient storage space</li>
</ul>

<p>Before diving into details, please make sure you completely understood what the sparse merkle tree is. These articles would be helpful if you never heard sparse merkle tree:</p>

<ul>
  <li><a href="https://medium.com/@kelvinfichter/whats-a-sparse-merkle-tree-acda70aeb837" title="whats a sparse merkle tree">whats a sparse merkle tree</a></li>
  <li><a href="https://ethresear.ch/t/optimizing-sparse-merkle-trees/3751" title="Optimizing sparse Merkle trees">Optimizing sparse Merkle trees</a></li>
</ul>

<hr />

<p>Optimization 1: Zero-value optimized hash function.</p>

<p>A sparse merkle tree contains a lot of zero values. That is the reason why we call it a ‘sparse’ merkle tree. By optimizing these zero values, we can save a lot of calculations.</p>

<p>We define the node merging function as following:</p>

<ol>
  <li>if L == 0, return R</li>
  <li>if R == 0, return L</li>
  <li>otherwise return sha256(L, R)</li>
</ol>

<p>In a naive sparse merkle tree construction, we usually pre-calculate the hash set of the default SMT(a tree that all values are zeros). When we access the default nodes, instead of duplicated calculation, we fetch the result from the pre-calculated hash set. The drawback is we need to save the pre-calculated result somewhere before we can use it. It may be costly, especially when we want to use SMT in a blockchain contract.</p>

<p>With optimization 1, we do not need the pre-calculated hash-set. For a default SMT, all the intermediate nodes are zero values. Thus, we only need to calculate the hash for non-zero nodes and return zero for the default nodes.</p>

<p>There’s only one issue that remains. The optimized hash function produces the same value from different key-value pairs, for example:  <code class="language-plaintext highlighter-rouge">merge(N, 0) == merge(0, N)</code>. This behavior opens a weak point for the SMT. An attacker may construct a collision of merkle root from a faked key-value map.</p>

<p>To fix this, we use the result of <code class="language-plaintext highlighter-rouge">hash(key | value)</code>  as a leaf’s hash, for examples: <code class="language-plaintext highlighter-rouge">merge(N, leaf_hash(N, 0)) == merge(0, leaf_hash(0, N))</code> the result is false because the <code class="language-plaintext highlighter-rouge">leaf_hash(N, 0)</code> is never equals to <code class="language-plaintext highlighter-rouge">leaf_hash(0, N)</code> if <code class="language-plaintext highlighter-rouge">N != 0</code>, the attacker can’t construct a collision attacking.</p>

<p>Additionally, we store <code class="language-plaintext highlighter-rouge">leaf_hash -&gt; value</code>  in a map to keep the reference to the original value.</p>

<p>We can prove the security of this construction.</p>

<ul>
  <li>Since the <code class="language-plaintext highlighter-rouge">key</code> is included in the leaf’s hash, and <code class="language-plaintext highlighter-rouge">key</code> is unique in SMT, no matter what the <code class="language-plaintext highlighter-rouge">value</code> is, the <code class="language-plaintext highlighter-rouge">leaf_hash(key, value)</code> is unique.</li>
  <li>Each node is either merged by two different hashes or merged by a hash with a zero-value. We already knew that all leaves have a unique hash, so their parent nodes also have a unique hash, and so on. The parent of these parent nodes also has a unique hash until the root of the tree.</li>
  <li>We got zero value merkle root if the tree is empty. Otherwise, the root is merged from its two children nodes. Any changes in the leaves will also change the root hash.</li>
</ul>

<p>So we believe this construction is security because we can’t construct a collision of merkle root.</p>

<hr />

<p>Optimization 2: Compress the storage for duplicated nodes.</p>

<p>In the classic construction of SMT: We store a node with its two children as <code class="language-plaintext highlighter-rouge">Node {left, right}</code>, but with the zero-value optimization, mostly intermediate nodes in the tree are duplicated, these nodes occupied spaces but provide no additional information of the tree, we want our tree only stores unique-value nodes.</p>

<p>The idea is simple: for a single leaf SMT, we only store the leaf itself. When inserting another new leave, the merging happens. Instead of inserting a parent at each height, we only store the parent node once, plus the merging height of the two branches from leaves.</p>

<p>The trick is that we can simulate the <code class="language-plaintext highlighter-rouge">Node {leaf, right}</code> structure and pretend that we stored all the ancestor nodes in each height of the tree if we can extract the merging order information from somewhere.</p>

<p>The key to this trick is the leaf’s <code class="language-plaintext highlighter-rouge">key</code>.  Each key in the SMT can be seen as a path from the tree’s root to the leaf. With the path information, we can extract the merging order of hashes at each height, so when inserting a new leaf, we also store the leaf’s key in node, and when we need to merge two nodes, we extract the merging order from the key path:</p>

<p>We can calculate the merging height of two leaves by their key(or key path):</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">common_height</span><span class="p">(</span><span class="n">key1</span><span class="p">,</span> <span class="n">key2</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">255</span><span class="o">..</span><span class="mi">0</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">key1</span><span class="nf">.get_bit</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">!=</span> <span class="n">key2</span><span class="nf">.get_bit</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// common height</span>
            <span class="k">return</span> <span class="n">i</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The node structure is like <code class="language-plaintext highlighter-rouge">BranchNode { fork_height, key, node, sibling}</code>, we use <code class="language-plaintext highlighter-rouge">node</code> to represent all duplicated intermediate nodes, plus an additional field <code class="language-plaintext highlighter-rouge">key</code> to store the path information, with <code class="language-plaintext highlighter-rouge">key</code>, we can calculate the merging order of nodes between height <code class="language-plaintext highlighter-rouge">[node.fork_height, 255]</code>.</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">fork_height</code> is the height that the node is merged; for a leaf, it is 0.</li>
  <li><code class="language-plaintext highlighter-rouge">key</code> is copied from one of the node’s children. for a leaf node, the key is the leaf’s key.</li>
  <li><code class="language-plaintext highlighter-rouge">node</code> and <code class="language-plaintext highlighter-rouge">sibling</code> are like the <code class="language-plaintext highlighter-rouge">left</code> and <code class="language-plaintext highlighter-rouge">right</code> in the classic node structure. The difference is that the position of nodes depends on the merging height.</li>
</ul>

<p>To get a left child of a node in height <code class="language-plaintext highlighter-rouge">H</code>:</p>

<ol>
  <li>check <code class="language-plaintext highlighter-rouge">H</code>-th bit of key</li>
  <li>if it is <code class="language-plaintext highlighter-rouge">1</code> means the <code class="language-plaintext highlighter-rouge">node</code> is on the right at height <code class="language-plaintext highlighter-rouge">H</code>, so <code class="language-plaintext highlighter-rouge">sibling</code> is the left child</li>
  <li>if it is <code class="language-plaintext highlighter-rouge">0</code> means the <code class="language-plaintext highlighter-rouge">node</code> is on the left, so <code class="language-plaintext highlighter-rouge">sibling</code> is the right child</li>
</ol>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// get children at height</span>
<span class="c1">// return value is (left, right)</span>
<span class="k">fn</span> <span class="nf">children</span><span class="p">(</span><span class="n">branch_node</span><span class="p">,</span> <span class="n">height</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">is_rhs</span> <span class="o">=</span> <span class="n">branch_node</span><span class="py">.key</span><span class="nf">.get_bit</span><span class="p">(</span><span class="n">height</span><span class="p">);</span>
    <span class="k">if</span> <span class="n">is_rhs</span> <span class="p">{</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">branch_node</span><span class="py">.sibling</span><span class="p">,</span> <span class="n">branch_node</span><span class="py">.node</span><span class="p">)</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">branch_node</span><span class="py">.node</span><span class="p">,</span> <span class="n">branch_node</span><span class="py">.sibling</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>To get a leaf by a key, we walk down the tree from root to bottom:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">get</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">node</span> <span class="o">=</span> <span class="n">root</span><span class="p">;</span>
    <span class="c1">// path order by height</span>
    <span class="k">let</span> <span class="n">path</span> <span class="o">=</span> <span class="nn">BTreeMap</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
    <span class="k">loop</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">branch_node</span> <span class="o">=</span> <span class="k">match</span> <span class="n">map</span><span class="nf">.get</span><span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="p">{</span>
            <span class="nf">Some</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="n">b</span><span class="p">,</span>
            <span class="nb">None</span> <span class="k">=&gt;</span> <span class="k">break</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="c1">// common height may be lower than node.fork_height</span>
        <span class="k">let</span> <span class="n">height</span> <span class="o">=</span> <span class="nf">max</span><span class="p">(</span><span class="nf">common_height</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">node</span><span class="py">.key</span><span class="p">),</span> <span class="n">node</span><span class="py">.fork_height</span><span class="p">);</span>
        <span class="k">if</span> <span class="n">height</span> <span class="o">&gt;</span> <span class="n">node</span><span class="py">.fork_height</span> <span class="p">{</span>
            <span class="c1">// node is sibling, end search</span>
            <span class="n">path</span><span class="nf">.push</span><span class="p">(</span><span class="n">heignt</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="c1">// node is parent</span>
        <span class="c1">// extract children position from branch</span>
        <span class="k">let</span> <span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span> <span class="o">=</span> <span class="nf">children</span><span class="p">(</span><span class="n">branch_node</span><span class="p">,</span> <span class="n">height</span><span class="p">);</span>
        <span class="c1">// extract key positon</span>
        <span class="k">let</span> <span class="n">is_right</span> <span class="o">=</span> <span class="n">key</span><span class="nf">.get_bit</span><span class="p">(</span><span class="n">height</span><span class="p">);</span>
        <span class="k">if</span> <span class="n">is_right</span> <span class="p">{</span>
            <span class="n">path</span><span class="nf">.push</span><span class="p">(</span><span class="n">height</span><span class="p">,</span> <span class="n">left</span><span class="p">);</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">right</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">path</span><span class="nf">.push</span><span class="p">(</span><span class="n">height</span><span class="p">,</span> <span class="n">right</span><span class="p">);</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">left</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="k">self</span><span class="py">.leaves</span><span class="p">[</span><span class="n">node</span><span class="p">];</span>
<span class="p">}</span>
</code></pre></div></div>

<p>We use a similar algorithm to extract merging height information for other operations: updating and generate merkle proof. You can check the code for details.</p>

<p>Link of the <a href="https://github.com/jjyr/sparse-merkle-tree">code repo</a>.</p>


</article>

  </main>

   <footer>
  <a href="https://creativecommons.org/licenses/by-nc/3.0/deed.en_US">
    <span>
      JJy
    </span>
    
    <span>© 2024</span>
  </a>
</footer>

</body>

</html>
