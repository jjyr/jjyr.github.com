I""$<p>看了道 leetcode 题目
https://leetcode.com/problems/ones-and-zeroes/description/</p>

<p>这其实是一道背包问题，使用背包的状态转移方程可以简单解决</p>

<p>轻轻松松试了下手，果断翻车了…</p>

<p>我发现并不是题目难，而是我一直没能真正理解背包算法为何会这样来设计？
每次看到解答都会感觉反直觉，无法将直觉思路联系到这种解法，而网上的解题过程也大多由结果出发，没有掌握到 why</p>

<p>看题目时我的直觉是对每一个字符串判断需不需要，然后利用递归计算，算法如下。</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">find_max_form</span><span class="p">(</span><span class="n">strs</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
    <span class="n">str</span> <span class="o">=</span> <span class="n">strs</span><span class="p">.</span><span class="nf">first</span> <span class="c1"># 当前字符串</span>
    <span class="n">strs</span> <span class="o">=</span> <span class="n">strs</span><span class="p">[</span><span class="mi">1</span><span class="o">..-</span><span class="mi">1</span><span class="p">]</span> <span class="c1"># 剩余部分</span>
    <span class="n">m1</span> <span class="o">=</span> <span class="n">str</span><span class="o">&amp;</span><span class="p">.</span><span class="nf">count</span><span class="p">(</span><span class="s1">'0'</span><span class="p">)</span>
    <span class="n">n1</span> <span class="o">=</span> <span class="n">str</span><span class="o">&amp;</span><span class="p">.</span><span class="nf">count</span><span class="p">(</span><span class="s1">'1'</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">str</span><span class="p">.</span><span class="nf">nil?</span>
        <span class="mi">0</span>
    <span class="k">elsif</span> <span class="n">m1</span> <span class="o">&gt;</span> <span class="n">m</span> <span class="o">||</span> <span class="n">n1</span> <span class="o">&gt;</span> <span class="n">n</span>
        <span class="c1"># 放弃不满足条件的当前字符串</span>
        <span class="n">find_max_form</span><span class="p">(</span><span class="n">strs</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
    <span class="k">else</span>
        <span class="c1"># 选择构成当前的字符串时的数量 find_max_form(strs, m - m1, n - n1) + 1</span>
        <span class="c1"># 选择不构成当前字符串时的数量 find_max_form(strs, m, n)</span>
        <span class="c1"># 取大的作为真正解</span>
        <span class="p">[</span><span class="n">find_max_form</span><span class="p">(</span><span class="n">strs</span><span class="p">,</span> <span class="n">m</span> <span class="o">-</span> <span class="n">m1</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="n">n1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">find_max_form</span><span class="p">(</span><span class="n">strs</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">)].</span><span class="nf">max</span>
    <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>很符合直觉的递归，结果是执行超时。</p>

<p>主要问题是其计算过程是自上而下，每次计算都会需要两个子递归运算的结果，最后递归的数量是 2 的 N(strs长度) 次方。</p>

<p>而正解巧妙的修复了这个问题，思路就是将自上而下的算法巧妙的转换为自下而上，让每个子计算的结果都被重复利用。</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">find_max_form</span><span class="p">(</span><span class="n">strs</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
    <span class="n">dp</span> <span class="o">=</span> <span class="no">Array</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">strs</span><span class="p">.</span><span class="nf">size</span> <span class="o">+</span> <span class="mi">1</span><span class="p">){</span><span class="no">Array</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">m</span> <span class="o">+</span> <span class="mi">1</span><span class="p">){</span><span class="no">Array</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)}}</span>
    <span class="p">(</span><span class="n">strs</span><span class="p">.</span><span class="nf">size</span> <span class="o">+</span> <span class="mi">1</span><span class="p">).</span><span class="nf">times</span> <span class="k">do</span> <span class="o">|</span><span class="n">i</span><span class="o">|</span>
        <span class="n">str</span> <span class="o">=</span> <span class="n">strs</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">s0</span> <span class="o">=</span> <span class="n">str</span><span class="p">.</span><span class="nf">count</span><span class="p">(</span><span class="s1">'0'</span><span class="p">)</span>
        <span class="n">s1</span> <span class="o">=</span> <span class="n">str</span><span class="p">.</span><span class="nf">count</span><span class="p">(</span><span class="s1">'1'</span><span class="p">)</span>
        <span class="p">(</span><span class="n">m</span> <span class="o">+</span> <span class="mi">1</span><span class="p">).</span><span class="nf">times</span> <span class="k">do</span> <span class="o">|</span><span class="n">j</span><span class="o">|</span>
            <span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">).</span><span class="nf">times</span> <span class="k">do</span> <span class="o">|</span><span class="n">k</span><span class="o">|</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span>
                    <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">elsif</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="n">s0</span> <span class="o">&amp;&amp;</span> <span class="n">k</span> <span class="o">&gt;=</span> <span class="n">s1</span>
                    <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">dp</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">j</span> <span class="o">-</span> <span class="n">s0</span><span class="p">][</span><span class="n">k</span> <span class="o">-</span> <span class="n">s1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">][</span><span class="n">k</span><span class="p">]].</span><span class="nf">max</span>
                <span class="k">else</span>
                    <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">][</span><span class="n">k</span><span class="p">]</span>
                <span class="k">end</span>
            <span class="k">end</span>
        <span class="k">end</span>
    <span class="k">end</span>
    <span class="n">dp</span><span class="p">[</span><span class="n">strs</span><span class="p">.</span><span class="nf">size</span><span class="p">][</span><span class="n">m</span><span class="p">][</span><span class="n">n</span><span class="p">]</span>
<span class="k">end</span>
</code></pre></div></div>

<p>正解很聪明的将“第N个包”放不放的问题，转换为保存“前N个包的最优解”，从而让每个计算都可以利用之前的结果。</p>
:ET