I"\<p>最近对Actor模式很有兴趣(Celluloid), 记下自己的心得和对Actor模式的理解。</p>

<p>要想知道一个东西有什么必要性，就要知道没有它的话是什么样子</p>

<p>如果没有struct…</p>
<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">point1x</span> <span class="o">=</span> <span class="n">point1y</span> <span class="o">=</span> <span class="n">point2x</span> <span class="o">=</span> <span class="n">point2y</span> <span class="o">=</span> <span class="mi">0</span>
</code></pre></div></div>

<p>如果没有class…</p>
<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">rectangle_area</span> <span class="n">rect</span>
  <span class="c1">#something...</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nf">circle_area</span> <span class="n">circle</span>
  <span class="c1">#something...</span>
<span class="k">end</span>
<span class="c1">#etc...</span>
</code></pre></div></div>

<p>如果没有actor…</p>
<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1">#好吧，可能没有的话也没什么关系..</span>
</code></pre></div></div>

<p>当然还是有关系的..
比如我们设计一个账户</p>
<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Account</span>
  <span class="nb">attr_accessor</span> <span class="ss">:money</span>

  <span class="k">def</span> <span class="nf">take_money</span> <span class="n">amount</span>
    <span class="k">if</span> <span class="n">amount</span> <span class="o">&lt;</span> <span class="n">money</span>
      <span class="n">new_amount</span> <span class="o">=</span> <span class="n">money</span> <span class="o">-</span> <span class="n">amount</span>
      <span class="nb">self</span><span class="p">.</span><span class="nf">money</span> <span class="o">=</span> <span class="n">new_amount</span>
      <span class="s2">"ok!"</span>
    <span class="k">else</span>
      <span class="s2">"no enough money :("</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>
<p>刚看到我就笑了，居然不用锁！要是有并发请求take_money不是有机会取出双份的钱吗</p>

<p>当然..我们可以把程序中所有危险的地方都加上锁，但是锁带来的死锁等问题相信写过这类程序的人都知道其麻烦之处(我没写过)</p>

<p>其实更简单的方法就是看下为什么会造成这样，然后把原因消除就好</p>

<p>原因很明显，因为有不同的thread来执行这段代码，所以会造成脏数据，需要用锁来保证这段代码必须是只能一个thread来执行</p>

<p>当然更简单的方法其实真的很简单..与其引入锁来保证这段代码只能被唯一的thread执行，不如我们让所有的代码都只能被一个thread来执行，这样当然就不需要锁了</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">require</span> <span class="s1">'celluloid'</span>
<span class="k">class</span> <span class="nc">Account</span>

  <span class="kp">include</span> <span class="no">Celluloid</span>

  <span class="nb">attr_accessor</span> <span class="ss">:money</span>

  <span class="k">def</span> <span class="nf">initialize</span>
    <span class="vi">@money</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">take_money</span> <span class="n">amount</span>
    <span class="k">if</span> <span class="n">amount</span> <span class="o">&lt;</span> <span class="n">money</span>
      <span class="n">new_amount</span> <span class="o">=</span> <span class="n">money</span> <span class="o">-</span> <span class="n">amount</span>
      <span class="nb">self</span><span class="p">.</span><span class="nf">money</span> <span class="o">=</span> <span class="n">new_amount</span>
      <span class="s2">"ok!"</span>
    <span class="k">else</span>
      <span class="s2">"no enough money :("</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">save_money</span> <span class="n">amount</span>
    <span class="n">new_amount</span> <span class="o">=</span> <span class="n">money</span> <span class="o">+</span> <span class="n">amount</span>
    <span class="nb">self</span><span class="p">.</span><span class="nf">money</span> <span class="o">=</span> <span class="n">new_amount</span>
    <span class="s2">"ok!"</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>
<p>ruby + celluloid真的很方便..看起来就像是单线程程序， 实际上每个Account内部的确是单线程
但是已经可以避免之前的问题了，无论存钱还是取钱都是安全的！而且我们几乎都没有改动代码</p>

<p>不过此时的Account已经不是过去的他了， 每个实例都从object蜕变为了actor…</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">a</span> <span class="o">=</span> <span class="no">Account</span><span class="p">.</span><span class="nf">new</span>
<span class="n">a</span><span class="p">.</span><span class="nf">save_money</span> <span class="mi">10000000000000000000000000000000000000000000000000000000000000000000</span>
<span class="n">a</span><span class="p">.</span><span class="nf">take_money</span> <span class="mi">5</span>
</code></pre></div></div>
<p>当我们调用方法时其实已经不是直接的调用，而是对actor发送消息，然后actor内部用自己的线程去执行，之后返回给我们消息，所以执行我们代码的永远只有一个线程，自然不需要锁
而每个actor会有一个邮箱来接受消息，之后actor线程去执行(你可能想到生产者消费者模式，那么你就对了)</p>

<p>所以当多个线程去并发的请求actor,实际上是一个Queue#push操作(这也是’无锁’的Actor必要的一个锁)</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>struct == datas
class == struct + method
actor == class + thread!!
</code></pre></div></div>
:ET