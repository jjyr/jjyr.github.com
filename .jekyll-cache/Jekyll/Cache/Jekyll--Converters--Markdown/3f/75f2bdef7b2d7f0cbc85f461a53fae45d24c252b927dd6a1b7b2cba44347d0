I"<p>######Celluloid有个很<a href="https://github.com/celluloid/celluloid/wiki/Exclusive">神奇的机制</a>（&lt;–示例代码）</p>

<p>Celluloid每次任务(方法调用)会用Fiber去包装</p>

<p>当一个FiberTask因为<strong>某些代码</strong>被中断时，此时Celluloid可以回到<a href="https://github.com/celluloid/celluloid/blob/master/lib/celluloid/actor.rb#L418">线程执行任务的方法</a></p>

<p><strong>相当于</strong>中断的任务已经结束</p>

<p>之后Actor线程继续的从mailbox<a href="https://github.com/celluloid/celluloid/blob/master/lib/celluloid/actor.rb#L168">取任务</a></p>

<p>######某些代码!
FiberTask会因某些方法被中断，上面的示例代码中中断当前Fiber的是sleep方法，这个方法由Celluloid做了覆盖</p>
<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">sleeper</span> <span class="o">=</span> <span class="no">Sleeper</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="vi">@timers</span><span class="p">,</span> <span class="n">interval</span><span class="p">)</span>
  <span class="no">Celluloid</span><span class="p">.</span><span class="nf">suspend</span><span class="p">(</span><span class="ss">:sleeping</span><span class="p">,</span> <span class="n">sleeper</span><span class="p">)</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">Celluloid.suspend</code>这行代码就起到中断作用，(知道它会中断当前Fiber即可，实际会根据后边的参数调用一些callback)</p>

<p>######中断了。。如何恢复？</p>
<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">def</span> <span class="nf">before_suspend</span><span class="p">(</span><span class="n">task</span><span class="p">)</span>
    <span class="vi">@timers</span><span class="p">.</span><span class="nf">after</span><span class="p">(</span><span class="vi">@interval</span><span class="p">)</span> <span class="p">{</span> <span class="n">task</span><span class="p">.</span><span class="nf">resume</span> <span class="p">}</span>
  <span class="k">end</span>
</code></pre></div></div>

<p>这就是参数sleeper的callback,可以看到利用定时器来执行恢复的task</p>

<p>如果Fiber.resume的时候当前正在执行别的FiberTask会怎么办？岂不是会乱掉？</p>

<p>after定时器也是通过<a href="https://github.com/celluloid/celluloid/blob/master/lib/celluloid/actor.rb#L279">FiberTask</a>来执行的，所以到时间后我们的block会被传到mailbox中，就像一个新任务被调用一样，完全没有问题!</p>

<p>######某些方法能中断？
actor当然不是再任何情况下都可以自己中断..上文<code class="highlighter-rouge">sleep</code>方法是之一，另外Celluloid还提供了<code class="highlighter-rouge">Condition</code>类来进行中断</p>

<p>Condition类和<a href="http://rdoc.info/stdlib/thread/ConditionVariable#">ConditionVariable</a>行为类似</p>

<p>######Condition
ConditionVariable主要是用来在线程间统一资源的，README很详细</p>

<p>在Celluloid中应该用<code class="highlighter-rouge">Celluloid::Condition</code>来完成这件事，他们的行为是差不多的</p>

<p><code class="highlighter-rouge">Celluloid::Condition</code>的好处是会<a href="https://github.com/celluloid/celluloid/blob/master/lib/celluloid/condition.rb#L48">中断当前的FiberTask</a>, 这样Actor可以去执行之后的Task,而不是一直block住,基本原理和之前<code class="highlighter-rouge">sleep</code>是差不多的</p>

<p>Condition可以很好用的去做些同步操作，而且不会浪费线程</p>
:ET