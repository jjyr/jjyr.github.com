<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>JJy | Merkle Mountain Range</title>
  <link rel="stylesheet" href=" /css/main.css">
  <link href="/atom.xml" type="application/atom+xml" rel="alternate" title="ATOM Feed" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.6.0/css/all.min.css" integrity="sha512-Kc323vGBEqzTmouAECnVceyQqyqdsSiqLQISBL29aUW4U/M7pSPA/gEUZQqv1cwx4OnYxTxve5UMg5GT6L4JJg==" crossorigin="anonymous" referrerpolicy="no-referrer" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-light.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
  
  <!-- and it's easy to individually load additional languages -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/c.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/rust.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/javascript.min.js"></script>
  
  <script>hljs.highlightAll();</script>
</head>


<body>
  <header>
  <nav>
    <ul>
        <li><a href=" /">All</a></li>
        <li><a href=" /about">@JJy</a></li>
        <li><a href=" /atom.xml">RSS</a></li>
    </ul>
</nav>

</header>

  <main class="container">
    <article>
  <header>
    <h2>Merkle Mountain Range</h2>
    <time datetime=" 2019-07-03" class="post-meta">2019-07-03</time>
    <p>
      
      <a class="post-link" href=" tags/merkletree">Merkletree</a>
      
      <a class="post-link" href=" tags/cryptography">Cryptography</a>
      
      <a class="post-link" href=" tags/english">English</a>
      
    </p>
  </header>
  <h2 id="merkle-tree">Merkle Tree</h2>

<p>Merkle Tree 是区块链中经常（或者说必须？）会用到结构。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 比特币交易列表的 Merkle Tree

            A
          /   <span class="se">\</span>
        B       C
       / <span class="se">\ </span>    / <span class="se">\</span>
      D   E   F   G
     / <span class="se">\ </span>/ <span class="se">\ </span>/ <span class="se">\ </span>/ <span class="se">\</span>
     1 2 3 4 5 6 7 8
</code></pre></div></div>

<p>树的叶子节点（图中的 <code class="language-plaintext highlighter-rouge">1,2,3,4,5,6,7,8</code>）是插入的元素，在图例中是比特币的 txid。
非叶子节点是对左右子节点的 hash 摘要如 <code class="language-plaintext highlighter-rouge">D = hash(1, 2)</code>, <code class="language-plaintext highlighter-rouge">B = hash(D, E)</code>。</p>

<p>树的根即 root hash (也叫 merkle root) 是对整棵树的摘要。</p>

<p>Merkle Tree 使用加密学 hash 方法保证安全性，只有以同样顺序插入同样的叶子节点才可以算出一致的 root hash。现在常用的 256 位 hash 碰撞的几率为 <code class="language-plaintext highlighter-rouge">1 / 2 ** 256</code>，几乎不会在现实中发生<a href="https://www.bilibili.com/video/av12467314">碰撞</a>。</p>

<p>Bitcoin 在区块头保存了交易列表的 merkle root，节点同步交易列表时通过计算 merkle root 并与块头的 <code class="language-plaintext highlighter-rouge">hashMerkleRoot</code> 对比来确认交易列表是否正确。</p>

<p>Merkle tree 的另一个特性，是可以证明某个元素是否是 merkle tree 的成员。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 比特币交易列表的 Merkle Tree

             A
           /   <span class="se">\</span>
         B       C.
       /  <span class="se">\ </span>     / <span class="se">\</span>
      D.    E   F    G
     / <span class="se">\ </span> /  <span class="se">\ </span>/ <span class="se">\ </span> / <span class="se">\</span>
     1 2 <span class="o">(</span>3<span class="o">)</span> 4. 5 6 7 8
</code></pre></div></div>

<p>我们发现，仅用图中标识 <code class="language-plaintext highlighter-rouge">.</code> 的节点就可以计算出 merkle root，我们可以计算从 tx3 到 merkle root 之间的中间节点 <code class="language-plaintext highlighter-rouge">E = hash(tx3, tx4)</code>，<code class="language-plaintext highlighter-rouge">B = hash(D, E)</code>，<code class="language-plaintext highlighter-rouge">A = hash(B, C)</code>。
计算过程恰好是叶子节点 <code class="language-plaintext highlighter-rouge">tx3</code> 到 merkle root <code class="language-plaintext highlighter-rouge">A</code> 的路径 <code class="language-plaintext highlighter-rouge">tx3 -&gt; E -&gt; B -&gt; A</code>，所以也叫做 merkle path。</p>

<p>利用这个特性我们可以向只有 <code class="language-plaintext highlighter-rouge">merkle root</code> 的人证明 <code class="language-plaintext highlighter-rouge">tx3</code> 是这个 merkle tree 的成员。
证据就是 <code class="language-plaintext highlighter-rouge">tx4, D, C</code>，这是 <code class="language-plaintext highlighter-rouge">tx3</code> 的 merkle proof。</p>

<p>Merkle proof 大小是 <code class="language-plaintext highlighter-rouge">树高度 - 1</code>, 叶子节点数量为 <code class="language-plaintext highlighter-rouge">n</code> 时，merkle proof 中 hash 数量为 <code class="language-plaintext highlighter-rouge">log(n)</code>，</p>

<p>Bitcoin 轻节点的 SPV 就是依赖 merkle proof，不需要发送完整交易列表，只需发送 <code class="language-plaintext highlighter-rouge">log(txs_count)</code> 个 hash 就可以证明块中包含某个交易。</p>

<p>全节点生成 Merkle 证明算法如下:</p>

<ol>
  <li>从树中需要证明的节点节点开始</li>
  <li>找到兄弟节点将其加入 proof</li>
  <li>跳转到父节点，如果抵达 root 节点则停止，否则回到第 2 步</li>
</ol>

<h2 id="merkle-mountain-range">Merkle Mountain Range</h2>

<p>Merkle Mountain Range (简称 MMR) 是 Peter Todd 提出的一种 Merkle Tree，被 Open timestamp 和 Grin 等项目使用，轻节点协议 Fly client 的论文中也使用 MMR 来做 Merkle proof。</p>

<p>MMR 被设计为 append only, 节点插入后就不会被修改，支持动态的插入。</p>

<p>MMR 和比特币的 Merkle tree 相比，更适合需要动态插入的场景。</p>

<p>比如 Fly client 协议的需求，对整条链中的区块头计算 merkle root 并放入下一个区块头中。如果每个块都重新构造这么庞大的 merkle tree 计算量会非常大，使用 MMR 可以动态的插入新区块头并计算 root hash。</p>

<p>而比特币 Merkle tree 的场景是静态的，在构造树前就已知整个交易列表，且列表不会变化。</p>

<p>MMR 的特点是 append only, 因为这个特性，我们可以用插入顺序作为节点的坐标。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// Height
3              14
             /    <span class="se">\</span>
            /      <span class="se">\</span>
           /        <span class="se">\</span>
          /          <span class="se">\</span>
2        6            13
       /   <span class="se">\ </span>       /    <span class="se">\</span>
1     2     5      9     12     17
     / <span class="se">\ </span>  / <span class="se">\ </span>   / <span class="se">\ </span>  /  <span class="se">\ </span>  /  <span class="se">\</span>
0   0   1 3   4  7   8 10  11 15  16 18
</code></pre></div></div>

<p>如图所述，插入了 11 个叶子节点的 MMR，节点数字代表插入的顺序，同时也是节点的坐标。</p>

<p>当插入新节点时，如果出现了同样高度的树，则需要进行合并。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// Height
3              14
             /    <span class="se">\</span>
            /      <span class="se">\</span>
           /        <span class="se">\</span>
          /          <span class="se">\</span>
2        6            13           21
       /   <span class="se">\ </span>       /    <span class="se">\ </span>      /    <span class="se">\</span>
1     2     5      9     12     17     20
     / <span class="se">\ </span>  / <span class="se">\ </span>   / <span class="se">\ </span>  /  <span class="se">\ </span>  /  <span class="se">\ </span>  /  <span class="se">\</span>
0   0   1 3   4  7   8 10  11 15  16 18  19
</code></pre></div></div>

<p>插入第 12 个叶子节点(节点 19)，因为 <code class="language-plaintext highlighter-rouge">18</code> 和 <code class="language-plaintext highlighter-rouge">19</code> 高度相同，合并两个叶子得到 <code class="language-plaintext highlighter-rouge">20</code>, 此时 <code class="language-plaintext highlighter-rouge">17</code> 和 <code class="language-plaintext highlighter-rouge">20</code> 高度相同，合并得到 <code class="language-plaintext highlighter-rouge">21</code>。</p>

<p>可以注意到，合并节点的次数和树的高度有关，树高为 <code class="language-plaintext highlighter-rouge">log(n)</code>, 增加叶子节点时最差的情况下需要插入 <code class="language-plaintext highlighter-rouge">log(n) + 1</code> 个节点。</p>

<h3 id="mmr-add">MMR add</h3>

<p>从图中可以观察到</p>

<ul>
  <li>父节点和左子节点 offset 为  <code class="language-plaintext highlighter-rouge">2 ** height</code></li>
  <li>兄弟节点间的 offset 为 <code class="language-plaintext highlighter-rouge">2 ** (height + 1) - 1</code></li>
</ul>

<p>利用这些特性可以计算出任意节点的兄弟节点和父节点的坐标。</p>

<p>MMR 插入操作需要判断是否合并，有两种做法：
一是判断节点高度和兄弟节点的高度是否相同，高度相同则进行合并；
二是计算下一个节点的高度，如果高于当前节点则需要合并。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 一个简单的做法:
# 1. 尝试找左侧的兄弟节点的高度
# 2. 高度与当前节点相同则合并
</span><span class="k">class</span> <span class="nc">MMR</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hasher</span><span class="o">=</span><span class="n">hashlib</span><span class="p">.</span><span class="n">blake2b</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">pos_height</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">need_merge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">height</span><span class="p">):</span>
        <span class="n">left_sibling_pos</span> <span class="o">=</span> <span class="n">pos</span> <span class="o">-</span> <span class="n">sibling_offset</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">pos_height</span><span class="p">[</span><span class="n">left_sibling_pos</span><span class="p">]</span> <span class="o">==</span> <span class="n">height</span>
</code></pre></div></div>

<p>这个算法比较简单直观，弊端是 MMR 必须维护一个数组来保存节点坐标和对应高度。</p>

<p>我们注意节点的高度只和节点坐标有关，能否通过节点坐标来计算出对应的高度？</p>

<p>观察图中最左侧的树可以发现不同高度的子树坐标隐含了节点数量，比如 6 为根的子树共有 (0 ~ 6) 7 个节点， 14 为根的树共有 (0 ~ 14) 15 个节点。
如果将坐标变为从 1 开始, 子树根坐标就恰好等于节点数。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// Grin 使用的算法，使用 1 based 二进制来表示节点坐标
Height

2        111
       /     <span class="se">\</span>
1     11     110       1010
     /  <span class="se">\ </span>   / <span class="se">\ </span>     /    <span class="se">\</span>
0   1   10 100 101  1000  1001  1011
</code></pre></div></div>

<p>每次高度上升，左子树要合并同样 n 节点的右子树并新增一个父节点，实际上相当于计算 <code class="language-plaintext highlighter-rouge">(n &lt;&lt; 1) + 1</code>。
表现在二进制则是图中最左侧根坐标 <code class="language-plaintext highlighter-rouge">1, 11, 111, 1111</code> 这样的形式, 恰好是高度加一。</p>

<p>我们从任何一个坐标开始(比如 1010)，将坐标不断向左跳转，直到坐标所有 bits 为 1，代表我们到达了最左侧节点，就可以得到高度。
因为坐标从 1 开始，和节点数量一致，我们发现将坐标向左跳转，相当于将左侧的树整个删除。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Height

2        111
       /     <span class="se">\</span>
1     11     110       1010
     /  <span class="se">\ </span>   / <span class="se">\ </span>     /    <span class="se">\</span>
0   1   10 100 101  1000  1001  1011

// 删除掉整个左侧树后，1010 坐标变成了 11

1     11
     /  <span class="se">\</span>
0   1   10 100
</code></pre></div></div>

<p>从 <code class="language-plaintext highlighter-rouge">1010</code> 坐标开始，减去左侧树(当前坐标最高有效位减一 <code class="language-plaintext highlighter-rouge">1000 - 1 =&gt; 111</code>), 可以向左跳转 <code class="language-plaintext highlighter-rouge">1010 - (1000 - 1) =&gt; 11</code>，不断重复这个过程直到得到全部 bits 为 1 的坐标。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">tree_pos_height</span><span class="p">(</span><span class="n">pos</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="c1"># 转换为从 1 开始的坐标
</span>    <span class="n">pos</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">all_ones</span><span class="p">(</span><span class="n">num</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">num</span><span class="p">.</span><span class="n">bit_length</span><span class="p">())</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">==</span> <span class="n">num</span>

    <span class="k">def</span> <span class="nf">jump_left</span><span class="p">(</span><span class="n">pos</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">most_significant_bits</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">pos</span><span class="p">.</span><span class="n">bit_length</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">pos</span> <span class="o">-</span> <span class="p">(</span><span class="n">most_significant_bits</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

    <span class="c1"># loop until we jump to all ones position, which is tree height
</span>    <span class="k">while</span> <span class="ow">not</span> <span class="n">all_ones</span><span class="p">(</span><span class="n">pos</span><span class="p">):</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="n">jump_left</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span>
    <span class="c1"># count all 1 bits
</span>    <span class="k">return</span> <span class="n">pos</span><span class="p">.</span><span class="n">bit_length</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span>
</code></pre></div></div>

<p>有了 <code class="language-plaintext highlighter-rouge">tree_pos_height</code> 方法，我们可以写入如下插入方法。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">MMR</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hasher</span><span class="o">=</span><span class="n">hashlib</span><span class="p">.</span><span class="n">blake2b</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">last_pos</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">pos_hash</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">_hasher</span> <span class="o">=</span> <span class="n">hasher</span>

    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">elem</span><span class="p">:</span> <span class="nb">bytes</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="s">"""
        Insert a new leaf
        """</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">last_pos</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">hasher</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">_hasher</span><span class="p">()</span>
        <span class="n">hasher</span><span class="p">.</span><span class="n">update</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span>
        <span class="c1"># 保存叶子节点的 hash
</span>        <span class="bp">self</span><span class="p">.</span><span class="n">pos_hash</span><span class="p">[</span><span class="bp">self</span><span class="p">.</span><span class="n">last_pos</span><span class="p">]</span> <span class="o">=</span> <span class="n">hasher</span><span class="p">.</span><span class="n">digest</span><span class="p">()</span>
        <span class="n">height</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">last_pos</span>
        <span class="c1"># 判断是否需要合并节点
</span>        <span class="c1"># tree_pos_height 根据节点坐标计算节点所在高度
</span>        <span class="c1"># 如果下个插入节点高度大于当前高度，代表需要合并
</span>        <span class="k">while</span> <span class="n">tree_pos_height</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">last_pos</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">height</span><span class="p">:</span>
            <span class="c1"># 合并的父节点坐标
</span>            <span class="bp">self</span><span class="p">.</span><span class="n">last_pos</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="c1"># 左子树
</span>            <span class="n">left_pos</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">last_pos</span> <span class="o">-</span> <span class="p">(</span><span class="mi">2</span> <span class="o">&lt;&lt;</span> <span class="n">height</span><span class="p">)</span>
            <span class="c1"># 右子树
</span>            <span class="n">right_pos</span> <span class="o">=</span> <span class="n">left_pos</span> <span class="o">+</span> <span class="n">sibling_offset</span><span class="p">(</span><span class="n">height</span><span class="p">)</span>
            <span class="n">hasher</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">_hasher</span><span class="p">()</span>
            <span class="c1"># 合并 Hash
</span>            <span class="n">hasher</span><span class="p">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">pos_hash</span><span class="p">[</span><span class="n">left_pos</span><span class="p">])</span>
            <span class="n">hasher</span><span class="p">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">pos_hash</span><span class="p">[</span><span class="n">right_pos</span><span class="p">])</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">pos_hash</span><span class="p">[</span><span class="bp">self</span><span class="p">.</span><span class="n">last_pos</span><span class="p">]</span> <span class="o">=</span> <span class="n">hasher</span><span class="p">.</span><span class="n">digest</span><span class="p">()</span>
            <span class="n">height</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">pos</span>

<span class="c1"># get left or right sibling offset by height
</span><span class="k">def</span> <span class="nf">sibling_offset</span><span class="p">(</span><span class="n">height</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="k">return</span> <span class="p">(</span><span class="mi">2</span> <span class="o">&lt;&lt;</span> <span class="n">height</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
</code></pre></div></div>

<h3 id="mmr-get_root">MMR get_root</h3>

<p>MMR 可能会出现多个“山峰”，要把多个山峰合并为一个 root hash，
这个操作被称为 “拱起”（Bagging）。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// Height
3              14
             /    <span class="se">\</span>
            /      <span class="se">\</span>
           /        <span class="se">\</span>
          /          <span class="se">\</span>
2        6            13
       /   <span class="se">\ </span>       /    <span class="se">\</span>
1     2     5      9     12     17
     / <span class="se">\ </span>  / <span class="se">\ </span>   / <span class="se">\ </span>  /  <span class="se">\ </span>  /  <span class="se">\</span>
0   0   1 3   4  7   8 10  11 15  16 18
</code></pre></div></div>

<p>“拱起” 操作从最右侧山峰，依次向左合并，直到只剩下 root hash。</p>

<p>如图 root hash 等于 <code class="language-plaintext highlighter-rouge">hash(hash(Node(18), Node(17)), Node(14))</code></p>

<p>只要能够找到所有山峰的坐标, 再进行 “拱起” 就可以得到 root hash。 因为 MMR 会不断合并子树，左侧的山峰一定是是个尽可能大的平衡二叉树，且节点数量为 <code class="language-plaintext highlighter-rouge">1 &lt;&lt; height + 1</code>。</p>

<p>在确定 MMR 节点数量为 <code class="language-plaintext highlighter-rouge">mmr_size</code> 的情况下，我们可以不断的尝试左侧山峰的高度，计算山峰的二叉树节点数量 <code class="language-plaintext highlighter-rouge">1 &lt;&lt; height + 1</code> 找到小于 <code class="language-plaintext highlighter-rouge">mmr_size</code> 的最大的树，此时的 height 就是左侧山峰的高度。</p>

<p>使用上一节的二进制节点坐标，可以从 height 转换为山峰的坐标。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">left_peak_height_pos</span><span class="p">(</span><span class="n">mmr_size</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
    <span class="k">def</span> <span class="nf">get_left_pos</span><span class="p">(</span><span class="n">height</span><span class="p">):</span>
        <span class="s">"""
        将高度转为从 1 开始的二进制的节点坐标: (1 &lt;&lt; height + 1) - 1
        再减去 1 得到从 0 开始的坐标
        """</span>
        <span class="k">return</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">height</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span>
    <span class="n">height</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">prev_pos</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">pos</span> <span class="o">=</span> <span class="n">get_left_pos</span><span class="p">(</span><span class="n">height</span><span class="p">)</span>
    <span class="c1"># 每次增加 height 1 尝试计算坐标
</span>    <span class="c1"># 如果坐标超出当前的 mmr_size，代表前一次结果正确
</span>    <span class="k">while</span> <span class="n">pos</span> <span class="o">&lt;</span> <span class="n">mmr_size</span><span class="p">:</span>
        <span class="n">height</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">prev_pos</span> <span class="o">=</span> <span class="n">pos</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="n">get_left_pos</span><span class="p">(</span><span class="n">height</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">height</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">prev_pos</span><span class="p">)</span>
</code></pre></div></div>

<p>计算出左侧山峰后，通过以下步骤寻找下一个山峰</p>

<ol>
  <li>以左侧山峰为当前坐标</li>
  <li>跳到当前坐标的右侧兄弟</li>
  <li>再跳到左侧子节点，如高度低于 0 则代表山峰不存在</li>
  <li>如果坐标小于 mmr size 则该坐标是山峰，否则回到第 3 步</li>
</ol>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">get_peaks</span><span class="p">(</span><span class="n">mmr_size</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
    <span class="k">def</span> <span class="nf">get_right_peak</span><span class="p">(</span><span class="n">height</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">mmr_size</span><span class="p">):</span>
        <span class="c1"># 跳到兄弟节点
</span>        <span class="n">pos</span> <span class="o">+=</span> <span class="n">sibling_offset</span><span class="p">(</span><span class="n">height</span><span class="p">)</span>
        <span class="c1"># 跳到左侧子节点
</span>        <span class="k">while</span> <span class="n">pos</span> <span class="o">&gt;</span> <span class="n">mmr_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">height</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">height</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># no right peak exists
</span>                <span class="k">return</span> <span class="p">(</span><span class="n">height</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
            <span class="n">pos</span> <span class="o">-=</span> <span class="mi">2</span> <span class="o">&lt;&lt;</span> <span class="n">height</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">height</span><span class="p">,</span> <span class="n">pos</span><span class="p">)</span>

    <span class="n">poss</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">height</span><span class="p">,</span> <span class="n">pos</span> <span class="o">=</span> <span class="n">left_peak_height_pos</span><span class="p">(</span><span class="n">mmr_size</span><span class="p">)</span>
    <span class="n">poss</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span>
    <span class="c1"># 高度为 0 时代表找到了所有的山峰
</span>    <span class="k">while</span> <span class="n">height</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">height</span><span class="p">,</span> <span class="n">pos</span> <span class="o">=</span> <span class="n">get_right_peak</span><span class="p">(</span><span class="n">height</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">mmr_size</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">height</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">poss</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">poss</span>
</code></pre></div></div>

<p>最后进行 “拱起” 得到 root hash</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">MMR</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">get_root</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bytes</span><span class="p">]:</span>
        <span class="c1"># 所有山峰坐标
</span>        <span class="n">peaks</span> <span class="o">=</span> <span class="n">get_peaks</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">last_pos</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="c1"># 合并
</span>        <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">_bag_rhs_peaks</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">peaks</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_bag_rhs_peaks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">peaks</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span>
                       <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bytes</span><span class="p">]:</span>
        <span class="n">rhs_peak_hashes</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="p">.</span><span class="n">pos_hash</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">peaks</span><span class="p">]</span>
        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">rhs_peak_hashes</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># 合并右山峰和左山峰
</span>            <span class="n">peak_r</span> <span class="o">=</span> <span class="n">rhs_peak_hashes</span><span class="p">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="n">peak_l</span> <span class="o">=</span> <span class="n">rhs_peak_hashes</span><span class="p">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="n">hasher</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">_hasher</span><span class="p">()</span>
            <span class="n">hasher</span><span class="p">.</span><span class="n">update</span><span class="p">(</span><span class="n">peak_r</span><span class="p">)</span>
            <span class="n">hasher</span><span class="p">.</span><span class="n">update</span><span class="p">(</span><span class="n">peak_l</span><span class="p">)</span>
            <span class="n">rhs_peak_hashes</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">hasher</span><span class="p">.</span><span class="n">digest</span><span class="p">())</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">rhs_peak_hashes</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">rhs_peak_hashes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span>
</code></pre></div></div>

<h3 id="mmr-gen_proof">MMR gen_proof</h3>

<p>MMR 构造 Merkle proof 非常简单：</p>

<ol>
  <li>构造从叶子节点到山峰的 merkle proof</li>
  <li>拱起右侧的山峰，将结果加入 proof</li>
  <li>将左侧的山峰从右到左加入 proof</li>
</ol>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// Height
3              14
             /    <span class="se">\</span>
            /      <span class="se">\</span>
           /        <span class="se">\</span>
          /          <span class="se">\</span>
2        6            13           21
       /   <span class="se">\ </span>       /    <span class="se">\ </span>      /    <span class="se">\</span>
1     2     5      9     12     17     20     24
     / <span class="se">\ </span>  / <span class="se">\ </span>   / <span class="se">\ </span>  /  <span class="se">\ </span>  /  <span class="se">\ </span>  /  <span class="se">\ </span>  /  <span class="se">\</span>
0   0   1 3   4  7   8 10  11 15  16 18  19 22  23 25
</code></pre></div></div>

<p>例子：构造叶子节点 <code class="language-plaintext highlighter-rouge">15</code> 的 Merkle proof</p>

<ol>
  <li>构造 <code class="language-plaintext highlighter-rouge">15</code> 到山峰的 <code class="language-plaintext highlighter-rouge">21</code> Merkle proof，proof = <code class="language-plaintext highlighter-rouge">16, 20</code></li>
  <li>拱起右侧山峰，右侧只有 <code class="language-plaintext highlighter-rouge">24</code> 和 <code class="language-plaintext highlighter-rouge">25</code>，结果为 <code class="language-plaintext highlighter-rouge">hash(25, 24)</code> 加入 proof，proof = <code class="language-plaintext highlighter-rouge">16, 20, hash(25, 24)</code>。</li>
  <li>将左侧的山峰从右到左的插入 proof，左侧只有 <code class="language-plaintext highlighter-rouge">14</code>，所以最终的 proof 为 <code class="language-plaintext highlighter-rouge">16, 20, hash(25, 24), 14</code>。</li>
</ol>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">MMR</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">gen_proof</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pos</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s">'MerkleProof'</span><span class="p">:</span>
        <span class="n">proof</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">height</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># 构造叶子节点到山峰的 Merkle proof
</span>        <span class="k">while</span> <span class="n">pos</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="p">.</span><span class="n">last_pos</span><span class="p">:</span>
            <span class="n">pos_height</span> <span class="o">=</span> <span class="n">tree_pos_height</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span>
            <span class="n">next_height</span> <span class="o">=</span> <span class="n">tree_pos_height</span><span class="p">(</span><span class="n">pos</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">next_height</span> <span class="o">&gt;</span> <span class="n">pos_height</span><span class="p">:</span>
                <span class="c1"># get left child sib
</span>                <span class="n">sib</span> <span class="o">=</span> <span class="n">pos</span> <span class="o">-</span> <span class="n">sibling_offset</span><span class="p">(</span><span class="n">height</span><span class="p">)</span>
                <span class="c1"># break if sib is out of mmr
</span>                <span class="k">if</span> <span class="n">sib</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="p">.</span><span class="n">last_pos</span><span class="p">:</span>
                    <span class="k">break</span>
                <span class="n">proof</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">pos_hash</span><span class="p">[</span><span class="n">sib</span><span class="p">])</span>
                <span class="c1"># goto parent node
</span>                <span class="n">pos</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># get right child
</span>                <span class="n">sib</span> <span class="o">=</span> <span class="n">pos</span> <span class="o">+</span> <span class="n">sibling_offset</span><span class="p">(</span><span class="n">height</span><span class="p">)</span>
                <span class="c1"># break if sib is out of mmr
</span>                <span class="k">if</span> <span class="n">sib</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="p">.</span><span class="n">last_pos</span><span class="p">:</span>
                    <span class="k">break</span>
                <span class="n">proof</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">pos_hash</span><span class="p">[</span><span class="n">sib</span><span class="p">])</span>
                <span class="c1"># goto parent node
</span>                <span class="n">pos</span> <span class="o">+=</span> <span class="mi">2</span> <span class="o">&lt;&lt;</span> <span class="n">height</span>
            <span class="n">height</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">peak_pos</span> <span class="o">=</span> <span class="n">pos</span>
        <span class="n">peaks</span> <span class="o">=</span> <span class="n">get_peaks</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">last_pos</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="c1"># 拱起右侧的山峰
</span>        <span class="n">rhs_peak_hash</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">_bag_rhs_peaks</span><span class="p">(</span><span class="n">peak_pos</span><span class="p">,</span> <span class="n">peaks</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">rhs_peak_hash</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">proof</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">rhs_peak_hash</span><span class="p">)</span>
        <span class="c1"># 从右向左插入左侧的山峰
</span>        <span class="n">proof</span><span class="p">.</span><span class="n">extend</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">_lhs_peaks</span><span class="p">(</span><span class="n">peak_pos</span><span class="p">,</span> <span class="n">peaks</span><span class="p">)))</span>
        <span class="k">return</span> <span class="n">MerkleProof</span><span class="p">(</span><span class="n">mmr_size</span><span class="o">=</span><span class="bp">self</span><span class="p">.</span><span class="n">last_pos</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
                           <span class="n">proof</span><span class="o">=</span><span class="n">proof</span><span class="p">,</span>
                           <span class="n">hasher</span><span class="o">=</span><span class="bp">self</span><span class="p">.</span><span class="n">_hasher</span><span class="p">)</span>
</code></pre></div></div>

<p>验证 Merkle proof 时按照同样顺序计算 Merkle Root 即可</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">MerkleProof</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mmr_size</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
                 <span class="n">proof</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">bytes</span><span class="p">],</span>
                 <span class="n">hasher</span><span class="p">):</span>
        <span class="s">"""
        MMR Merkle Proof
        包含 mmr_size 和 proof 列表
        """</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">mmr_size</span> <span class="o">=</span> <span class="n">mmr_size</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">proof</span> <span class="o">=</span> <span class="n">proof</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">_hasher</span> <span class="o">=</span> <span class="n">hasher</span>

    <span class="k">def</span> <span class="nf">verify</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="nb">bytes</span><span class="p">,</span> <span class="n">pos</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">elem</span><span class="p">:</span> <span class="nb">bytes</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="s">"""
        root - MMR root
        pos - 验证的叶子节点坐标
        elem - 验证的叶子节点内容
        """</span>
        <span class="n">peaks</span> <span class="o">=</span> <span class="n">get_peaks</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">mmr_size</span><span class="p">)</span>
        <span class="n">hasher</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">_hasher</span><span class="p">()</span>
        <span class="n">hasher</span><span class="p">.</span><span class="n">update</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span>
        <span class="n">elem_hash</span> <span class="o">=</span> <span class="n">hasher</span><span class="p">.</span><span class="n">digest</span><span class="p">()</span>
        <span class="n">height</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">proof</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">.</span><span class="n">proof</span><span class="p">:</span>
            <span class="n">hasher</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">_hasher</span><span class="p">()</span>
            <span class="c1"># 判断是否进入验证山峰的阶段
</span>            <span class="k">if</span> <span class="n">pos</span> <span class="ow">in</span> <span class="n">peaks</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">pos</span> <span class="o">==</span> <span class="n">peaks</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                    <span class="n">hasher</span><span class="p">.</span><span class="n">update</span><span class="p">(</span><span class="n">elem_hash</span><span class="p">)</span>
                    <span class="n">hasher</span><span class="p">.</span><span class="n">update</span><span class="p">(</span><span class="n">proof</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">hasher</span><span class="p">.</span><span class="n">update</span><span class="p">(</span><span class="n">proof</span><span class="p">)</span>
                    <span class="n">hasher</span><span class="p">.</span><span class="n">update</span><span class="p">(</span><span class="n">elem_hash</span><span class="p">)</span>
                    <span class="n">pos</span> <span class="o">=</span> <span class="n">peaks</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">elem_hash</span> <span class="o">=</span> <span class="n">hasher</span><span class="p">.</span><span class="n">digest</span><span class="p">()</span>
                <span class="k">continue</span>

            <span class="c1"># 验证子树的 Merkle proof
</span>            <span class="n">pos_height</span> <span class="o">=</span> <span class="n">tree_pos_height</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span>
            <span class="n">next_height</span> <span class="o">=</span> <span class="n">tree_pos_height</span><span class="p">(</span><span class="n">pos</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="c1"># 如果下个标作高度更高，证明当前是右子节点，否则当前为左子节点
</span>            <span class="k">if</span> <span class="n">next_height</span> <span class="o">&gt;</span> <span class="n">pos_height</span><span class="p">:</span>
                <span class="n">hasher</span><span class="p">.</span><span class="n">update</span><span class="p">(</span><span class="n">proof</span><span class="p">)</span>
                <span class="n">hasher</span><span class="p">.</span><span class="n">update</span><span class="p">(</span><span class="n">elem_hash</span><span class="p">)</span>
                <span class="n">pos</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">hasher</span><span class="p">.</span><span class="n">update</span><span class="p">(</span><span class="n">elem_hash</span><span class="p">)</span>
                <span class="n">hasher</span><span class="p">.</span><span class="n">update</span><span class="p">(</span><span class="n">proof</span><span class="p">)</span>
                <span class="n">pos</span> <span class="o">+=</span> <span class="mi">2</span> <span class="o">&lt;&lt;</span> <span class="n">height</span>
            <span class="n">elem_hash</span> <span class="o">=</span> <span class="n">hasher</span><span class="p">.</span><span class="n">digest</span><span class="p">()</span>
            <span class="n">height</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">elem_hash</span> <span class="o">==</span> <span class="n">root</span>
</code></pre></div></div>

<h2 id="参考">参考</h2>

<p>Merkle Mountain Range 的结构和名字一样非常容易理解，但想要正确的实现则需要掌握一些 trick, 文中使用的坐标计算算法大部分是参考自 Grin 的文档和源码。</p>

<ol>
  <li><a href="https://github.com/opentimestamps/opentimestamps-server/blob/master/doc/merkle-mountain-range.md">Merkle Mountain Range</a></li>
  <li><a href="https://github.com/mimblewimble/grin/blob/master/doc/mmr.md">Grin MMR 文档</a></li>
  <li><a href="https://github.com/mimblewimble/grin/blob/0ff6763ee64e5a14e70ddd4642b99789a1648a32/core/src/core/pmmr.rs#L606">Grin 源码注释 根据坐标计算高度</a></li>
  <li><a href="https://github.com/jjyr/mmr.py">mmr.py 完整的 MMR 实现</a></li>
  <li><a href="https://www.bilibili.com/video/av12467314">3Blue1Brown 256 位碰撞的概率</a></li>
</ol>


</article>

  </main>

   <footer>
  <a href="https://creativecommons.org/licenses/by-nc/3.0/deed.en_US">
    <span>
      JJy
    </span>
    
    <span>© 2024</span>
  </a>
</footer>

</body>

</html>
